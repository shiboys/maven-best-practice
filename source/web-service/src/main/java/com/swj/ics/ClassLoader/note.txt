结束一个JVM生命周期的方式：
System.exit
Normal finish done
Encounter the Error or exception
Crash


类加载器三个阶段：
加载：查找并加载类的二进制数据
链接：
    -验证：(Verifying) 确保被加载类的正确性
    -准备(Preparing) 为类的静态变量分配内存，并将其初始化为默认值（一般默认我0）
    -解析：把类中的符号引用转换为直接引用。
初始化：
    为类的静态变量赋予正确的初始化值
    
    
    
   1.3 Java程序对类的使用方式。
    1、被动使用
    2、主动使用
    
    所有的Java虚拟机实现必须在每个类或者接口被Java程序 首次主动使用 时才初始化他们，当然现代JVM有可能根据程序上下文的语义
    推断出来接下来可能初始化谁
    
1.4 主动使用的分类
    new，直接使用
    访问某个类或者接口的静态变量，或者对静态变量进行赋值操作
    调用静态方法
    反射某个类
    初始化一个子类
    启动类，比如java:HelloWorld
    除上述6个意外，其余的都是被动使用，不会导致类的初始化
    
    
 ***************************************第2节***************************************
 2.1类加载的最终产物是位于堆区中的Class对象。
 2.2 加载类的方式：
 从本地磁盘中直接加载
 从内存中直接接在
 通过网络加载.class  比如 URLClassLoader
 从zip,jar等归档文件中加载.class文件
 从数据库中提取.class文件
 动态编译
  ***************************************第3节 验证***************************************
  验证的主要目的是确保Class文件中的字节流包含的信息符合虚拟机的要求，并且不会损害到虚拟机自身的规范。
  VerifyError
  文件格式验证：
    魔术因子是否正确 0xCAFEBABE
    主从版本号是否符合当前虚拟机
    常量池中的常量类型是不是不支持
  元数据验证：
    是否有父类
    父类是否允许被继承
    是否实现了抽象方法
    是否覆盖了父类的final字段
    其他语义检查
  字节码验证：
    主要是进行数据流和控制流的分析，不会出现这样的情况：在操作栈中放置了一个int类型，但是却给了一个long类型的数据。
  符号引用验证：
    调用一个不存在的方法，字段等。NoSuchElementException.比如说将两个版本的jar文件都放在classPath中。
    
 3.2 准备阶段：
    就是给类变量分配初始值。
 3.3 解析
    类或者接口的解析
    字段解析
    类方法解析
    接口方法解析
    ***************************************第4节 初始化***************************************
    